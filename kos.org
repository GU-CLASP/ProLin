* Typing considerations
** Propositions
- Kos ::
  - Prop = [sit : Record; sit-type : RecordType]
  - propostion p=[sit = s0, sit-type = ST0] is true iff s0 : ST0
  
- ProLinKos :: Prop
** Questions
- Kos :: function that maps a record into a proposition (e.g. 3.39)
- ProLinKos :: follows AixDial
** Answers
- Kos :: ?
- ProLinKos :: follows AixDial

** FACTS
- Kos :: facts are propositions
- ProLinKos :: 
** QUD
- Kos :: questions with a special order (‘conversational precedency’,
  MaxQUD) and potentially co-dependent
- ProLinKos :: 
** MOVES (and LATEST-MOVE)
- Kos :: locutionary propostions: proposition + linguistic sign (speech act?)
- ProLinKos ::
* Conversational rules
** Turn-taking (4.21)
it seems that this can be encoded in other rules
*** no turn change
*** turn-change
*** turnholder-underspecified
** Greeting and parting (4.20, 4.22, 4.25, 4.26)
*** greeting
*** countergreeting
*** parting
*** counterparting
*** disengaging
** Asking, asserting, answering, accepting
*** Free speech
*** Asking
**** Kos
#+begin_example
LatestMove.Cont = Ask(A,q): IllocProp
1. A: push q onto QUD; release turn
2. B: push q onto QUD; take turn; make q-specific–utterance
#+end_example
**** ProLinKos
*** Asserting
**** Kos
#+begin_example
1. LatestMove.Cont = Assert(A, p): IllocProp
2. A: push p? onto QUD, release turn
3. B: push p? onto QUD, take turn; Option 1: Discuss p?,
   Option 2: Accept p
#+end_example
*** Assertion checking and confirming
*** Answering?

*** Accepting 
**** Kos
#+begin_example
1. LatestMove.Cont = Accept(B,p) : IllocProp
2. B: increment FACTS with p; pop p? from QUD;
3. A: increment FACTS with p; pop p? from QUD;
#+end_example
*** Fact update / QUD downdate
** Grounding and CRification
** NSUs
* Would be nice to test/implement
- Presuppositions (given that X / since we know that X). X should be added into facts. 
- Question accomodation (A: when? B: as cheap as possible). ?x.cheapest(x) should be added to QUD. 
- Enthymemes (A: why? B: because it is (...) )

